軽量ワークフローエンジンです

ペライチの python script がそのままワークフローエンジンとして動きます。

# チュートリアル

### 概要

[例](/examples/cli.py)

スクリプトを実行すると、ワークフローの実行し、結果を出力します。
状態は `setup()` で指定したバックエンドに保持されます。デフォルトではローカルファイルです。(今の所 s3 がおすすめ)
サーバプロセスが起動するわけではなく、一度処理したらすぐに終了します。

### 中断と再開

ワークフローは、中断し、再開することができます。

[例](/examples/infinite_loop.py)

`c.pause_once()` は一度だけワークフローを中断し、次回そこから再開することを意味します。
最初の実行では以下のような結果が得られます。

```
---------RUN SUMMARY---------
1件のワークフローが実行されました
        1件目
          ワークフロー名: loop
          run_id: 733543745
          状態: paused
          ログ:
            - loop: 0週目開始
```

2 回目は以下のようになります

```
---------RUN SUMMARY---------
1件のワークフローが実行されました
        1件目
          ワークフロー名: loop
          run_id: 733543745
          状態: paused
          ログ:
            - loop: 0週目開始
            - loop: 0週目おわり
            - loop: 1週目開始
```

メモリ上にあるはずの関数の実行状態を保存して、そこから復帰するように振る舞いますが、実際はそのようには動いていません。
ワークフローは常に関数の最初から普通に実行されます。
過去の中断記録から、`c.pause_once()`が中断するタイミングを遅らせているだけです。

普通はそのように処理すると、意図しない副作用が重複して実行されてしまうので困ります。

[例](/examples/infinite_loop_with_sideeffect.py)

この例ではワークフローの最初と最後、ループ中にも実際に副作用を引き起こす関数を実行しています。
しかし、最終的に実行される結果は以下の通りで、通知はこのログの通りにしか発行されません。

```
---------RUN SUMMARY---------
1件のワークフローが実行されました
        1件目
          ワークフロー名: loop
          run_id: 964408357
          状態: succeeded
          ログ:
            - sending message to your phone...:start!
            - sending message to your phone...:first loop... value is 1
            - sending message to your phone...:first loop... value is 2
            - sending message to your phone...:finish!
```

これは `@ttflow.sideeffect()` が、その副作用を最初の一回の呼び出ししか実行されないように制御しているからです。
また `get_state()` は単に値を読み出すだけでなく、再実行された場合はその時の値を返すようになっています。
`set_state()`は再実行時には何もしないようになっています。

これらの仕組みによって、ワークフローは実際には何度も再実行されるにも関わらず、あたかも途中状態を保存して中断・再開しているように振る舞います。

[例](/examples/watch_price.py)

これを応用すると、このようなワークフローを作成できます。
`買いたいもの追加` をトリガーすると、値段が安くなるまで無限に中断・再開して、指定した値段以下になったら通知を送ることができます。
`値段を取得` は実際には外部サービスから値段データを取得してくるところを適当なダミーに置き換えています。

```
---------RUN SUMMARY---------
1件のワークフローが実行されました
        1件目
          ワークフロー名: 買いたいもの追加
          run_id: 664143350
          状態: succeeded
          ログ:
            - 買いたいもの追加: レモン
            - 1回目: レモンは200で買えませんでした
            - 2回目: レモンは300で買えませんでした
            - 3回目: レモンは100円!
```

もちろん複数の品物を同時に監視することができます。

# 運用方法

ワークフローは、実行してすぐ終了するただのスクリプトなので、様々な運用方法が考えられます。

- ローカル PC に置いてコマンドで実行する
- サーバに置いて http 経由で実行する(永続化バックエンドはオンメモリ、ファイルなどが使えます)
- サーバレス関数実行環境(AWS lambda 等)に置く(永続化バックエンドには s3 等を使えます)

AWS lambda に置くのは非常に簡単なのでオススメです。
lambda の関数 URL から実行するためのハンドラ実装が `ttflow.powerup.run_by_lambda.run_by_lambda` で使えます。
`run_by_cli()` を `handler = run_by_lambda(ttflow)` 等で置き換えるだけで OK です。
